# Indirect Call Analysis

This document describes the LLM-based indirect call resolution feature, which uses a two-pass approach to analyze function pointer calls.

## Overview

Indirect calls (function pointer calls, virtual method calls) are challenging for static analysis because the call target is not known at compile time. This feature uses LLM analysis to resolve indirect calls by:

1. **Pass 1**: Summarizing where address-taken function pointers flow
2. **Pass 2**: Resolving indirect callsites using flow summaries

```
┌─────────────────────┐
│   Source Files      │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐     ┌─────────────────────┐
│ Address-Taken       │     │ Indirect Callsite   │
│ Scanner             │     │ Finder              │
└──────────┬──────────┘     └──────────┬──────────┘
           │                           │
           ▼                           │
┌─────────────────────┐                │
│ Pass 1: Flow        │                │
│ Summarizer (LLM)    │                │
└──────────┬──────────┘                │
           │                           │
           ▼                           ▼
┌─────────────────────────────────────────────────┐
│ Pass 2: Indirect Call Resolver (LLM)            │
│ - Uses flow summaries from Pass 1               │
│ - Signature-compatible candidates               │
└──────────────────────┬──────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────┐
│ Resolved Call Graph                             │
│ (indirect_call_targets table)                   │
└─────────────────────────────────────────────────┘
```

## Design Decisions

### Two-Pass Approach

**Why two passes instead of one?**

- **Reduced LLM calls**: Pass 1 makes one call per address-taken function (N calls). Pass 2 makes one call per callsite (M calls). Total: N + M calls, instead of N × M if we analyzed every function-callsite pair.
- **Better context**: Pass 1 builds comprehensive flow summaries that can be reused across multiple callsites.
- **Incremental updates**: If callsites change but address-taken functions don't, only Pass 2 needs to re-run.

### Signature-Only Pre-filtering

Candidates for indirect calls are filtered by signature compatibility before LLM analysis. No candidate limit is imposed - all signature-matching functions are passed to the LLM.

**Rationale**: Signature matching is a sound filter (incorrect signatures would cause runtime errors). The LLM is better at semantic matching than arbitrary candidate limits.

### compile_commands.json Support

When `compile_commands.json` is provided:
- Per-file compile flags are extracted and passed to libclang
- Proper macro expansion ensures conditionally-compiled functions are found
- Only source files (`.c`, `.cpp`) are processed (headers included via `#include`)

When not provided:
- Header files (`.h`, `.hpp`) are also processed directly
- Some conditionally-compiled code may be missed

## Components

### 1. Compile Commands Parser (`compile_commands.py`)

Parses `compile_commands.json` (generated by CMake, Bear, etc.) to extract per-file compile flags.

```python
from llm_summary.compile_commands import CompileCommandsDB

cc = CompileCommandsDB("build/compile_commands.json")
flags = cc.get_compile_flags("/path/to/source.c")
# Returns: ["-DFOO=1", "-I/path/to/include", ...]
```

**Extracted flags:**
- Include paths (`-I`, `-isystem`, `-iquote`)
- Defines (`-D`)
- Standard selection (`-std=`)
- Target triple (`-target`)

**Filtered out:**
- Compiler executable
- Output file (`-o`)
- Source file
- Dependency generation (`-M*`)

### 2. Address-Taken Scanner (`indirect/scanner.py`)

Finds functions whose addresses are taken.

**Detected patterns:**
- Explicit address-of: `&function`
- Implicit conversion: `callback = function`
- Passed as argument: `register(function)`
- Assigned to struct field: `handler->on_event = function`
- Array initialization: `handlers[0] = function`

**Output:**
- `address_taken_functions` table: function ID and signature
- `address_flows` table: where each address flows to

### 3. Indirect Callsite Finder (`indirect/callsites.py`)

Identifies indirect call expressions in the code.

**Detected patterns:**
- Member access: `ptr->callback(args)`, `obj.handler(args)`
- Array subscript: `handlers[i](args)`
- Dereference: `(*fptr)(args)`
- Variable: `callback(args)` where callback is a function pointer

**Output:**
- `indirect_callsites` table with caller, expression, signature, and context

### 4. Flow Summarizer (`indirect/flow_summarizer.py`)

**Pass 1**: Makes one LLM call per address-taken function.

**Input to LLM:**
- Function name and signature
- All locations where address is taken
- Context snippets around each location
- Function source code

**LLM Output:**
```json
{
  "flow_destinations": [
    {"type": "struct_field", "name": "handler_t.on_event", "confidence": "high"},
    {"type": "parameter", "name": "register_handler[0]", "confidence": "high"}
  ],
  "semantic_role": "Event handler callback for mouse clicks",
  "likely_callers": ["dispatch_event", "process_events"]
}
```

**Storage:** `address_flow_summaries` table

### 5. Indirect Call Resolver (`indirect/resolver.py`)

**Pass 2**: Makes one LLM call per indirect callsite.

**Input to LLM:**
- Callsite context (caller, expression, location)
- All signature-compatible candidates
- Flow summaries from Pass 1 for each candidate
- Source snippets

**LLM Output:**
```json
{
  "targets": [
    {"function": "handle_click", "confidence": "high", "reasoning": "..."},
    {"function": "handle_keypress", "confidence": "low", "reasoning": "..."}
  ]
}
```

**Storage:** `indirect_call_targets` table

## Database Schema

### New Tables

```sql
-- LLM-generated flow summaries for address-taken functions (Pass 1)
CREATE TABLE address_flow_summaries (
    id INTEGER PRIMARY KEY,
    function_id INTEGER NOT NULL REFERENCES functions(id) ON DELETE CASCADE,
    flow_destinations_json TEXT NOT NULL,  -- JSON array of destinations
    semantic_role TEXT,                     -- LLM's interpretation of callback purpose
    likely_callers_json TEXT,               -- JSON array of likely caller functions
    model_used TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(function_id)
);
```

### Existing Tables Used

```sql
-- Functions whose addresses are taken
address_taken_functions (id, function_id, signature)

-- Where function addresses flow to (static analysis)
address_flows (id, function_id, flow_target, file_path, line_number, context_snippet)

-- Indirect call sites
indirect_callsites (id, caller_function_id, file_path, line_number, callee_expr, signature, context_snippet)

-- Resolved indirect call targets
indirect_call_targets (callsite_id, target_function_id, confidence, llm_reasoning)
```

## CLI Usage

### Full Analysis

```bash
llm-summary indirect-analyze \
  --path src/ \
  --db analysis.db \
  --compile-commands build/compile_commands.json \
  --backend ollama \
  --model qwen3-coder:30b \
  --verbose
```

### Pass-by-Pass Analysis

```bash
# Run only Pass 1 (flow summarization)
llm-summary indirect-analyze --path src/ --db out.db --pass1-only

# Later, run only Pass 2 (resolution)
llm-summary indirect-analyze --path src/ --db out.db --pass2-only
```

### View Results

```bash
# Table format
llm-summary show-indirect --db analysis.db

# JSON format
llm-summary show-indirect --db analysis.db --format json
```

## Validation Results

Tested on libpng with ground truth from LLVM IR analysis:

| Metric | Result |
|--------|--------|
| Address-taken functions (ground truth) | 52 |
| Address-taken functions (detected) | 52 |
| True positives | 52 (100%) |
| False positives | 0 |
| False negatives | 0 |
| Indirect callsites found | 19 |

**Note**: Results with `compile_commands.json` are significantly better than without, due to proper macro expansion.

## Current Limitations

### Static Analysis Limitations

1. **Macro-dependent code**: Without `compile_commands.json`, conditionally-compiled functions may be missed
2. **Complex pointer arithmetic**: `*(table + offset)()` patterns may not be recognized
3. **Dynamic dispatch tables**: vtables and similar patterns need special handling
4. **Cross-TU analysis**: Function pointers passed between translation units may have incomplete flow information

### LLM Analysis Limitations

1. **Context window**: Very large functions or many candidates may exceed context limits
2. **Hallucination**: LLM may suggest targets that aren't actually reachable
3. **Confidence calibration**: Confidence levels are subjective

## Future Work

### TODO: Short-term

- [ ] **Signature compatibility checking**: Currently uses exact match; should support compatible signatures (e.g., `void*` vs `char*`)
- [ ] **Candidate deduplication**: Handle multiple definitions of same function
- [ ] **Better callee expression extraction**: Improve `(*unknown)` cases to extract actual expression
- [ ] **Virtual method support**: C++ virtual calls need vtable analysis

### TODO: Medium-term

- [ ] **Cross-TU flow tracking**: Track function pointers across translation units
- [ ] **Struct field type analysis**: Infer callback types from struct definitions
- [ ] **Array of function pointers**: Better handling of dispatch tables
- [ ] **Incremental Pass 2**: Only re-resolve callsites affected by code changes

### TODO: Long-term

- [ ] **Hybrid analysis**: Combine with dynamic analysis (execution traces)
- [ ] **Confidence calibration**: Train/tune confidence scores against ground truth
- [ ] **Interactive refinement**: Allow user to confirm/reject LLM suggestions
- [ ] **Integration with IDE**: Show resolved targets in editor

## File Reference

| File | Purpose |
|------|---------|
| `compile_commands.py` | Parse compile_commands.json |
| `indirect/__init__.py` | Package exports |
| `indirect/scanner.py` | Find address-taken functions |
| `indirect/callsites.py` | Find indirect callsites |
| `indirect/flow_summarizer.py` | Pass 1: LLM flow analysis |
| `indirect/resolver.py` | Pass 2: LLM call resolution |
| `models.py` | FlowDestination, AddressFlowSummary |
| `db.py` | Database schema and methods |
| `cli.py` | indirect-analyze, show-indirect commands |
