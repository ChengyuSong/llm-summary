"""Build script generator for reusable builds."""

import json
from datetime import datetime
from pathlib import Path
from typing import Any


class ScriptGenerator:
    """Generates reusable build scripts for projects."""

    def __init__(self, scripts_base_dir: Path | None = None):
        self.scripts_base_dir = scripts_base_dir or Path("build-scripts")

    def generate(
        self,
        project_name: str,
        project_path: Path,
        cmake_flags: list[str],
        container_image: str = "llm-summary-builder:latest",
        build_system: str = "cmake",
        enable_ir: bool = True,
    ) -> dict[str, Path]:
        """
        Generate a reusable build script for a project.

        Returns a dict with paths to generated files:
        - script: Path to build.sh
        - config: Path to config.json
        - artifacts_dir: Path to artifacts directory
        """
        # Create project directory
        project_dir = self.scripts_base_dir / project_name
        project_dir.mkdir(parents=True, exist_ok=True)

        # Create artifacts directory
        artifacts_dir = project_dir / "artifacts"
        artifacts_dir.mkdir(exist_ok=True)

        # Generate config.json
        config_path = self._generate_config(
            project_dir,
            project_name,
            str(project_path),
            cmake_flags,
            build_system,
        )

        # Generate build.sh
        script_path = self._generate_script(
            project_dir,
            project_name,
            str(project_path),
            cmake_flags,
            container_image,
            enable_ir,
        )

        return {
            "script": script_path,
            "config": config_path,
            "artifacts_dir": artifacts_dir,
        }

    def _generate_config(
        self,
        project_dir: Path,
        project_name: str,
        project_path: str,
        cmake_flags: list[str],
        build_system: str,
    ) -> Path:
        """Generate config.json metadata file."""
        config = {
            "project_name": project_name,
            "project_path": project_path,
            "build_system": build_system,
            "cmake_flags": cmake_flags,
            "generated_at": datetime.now().isoformat(),
        }

        config_path = project_dir / "config.json"
        config_path.write_text(json.dumps(config, indent=2))

        return config_path

    def _generate_script(
        self,
        project_dir: Path,
        project_name: str,
        project_path: str,
        cmake_flags: list[str],
        container_image: str,
        enable_ir: bool,
    ) -> Path:
        """Generate build.sh script."""
        # Determine configuration summary
        config_summary = []
        if any("LTO" in flag or "lto" in flag for flag in cmake_flags):
            config_summary.append("LTO enabled")
        if any("SHARED_LIBS=OFF" in flag for flag in cmake_flags):
            config_summary.append("static linking preferred")
        if any("save-temps" in flag for flag in cmake_flags):
            config_summary.append("LLVM IR generation")

        summary = ", ".join(config_summary) if config_summary else "default"

        # Format CMake flags for script
        formatted_flags = " \\\n           ".join(cmake_flags)

        # Generate script content
        script_content = f'''#!/bin/bash
# Generated build script for {project_name}
# Configuration: {summary}
# Generated by llm-summary build-learn on {datetime.now().strftime("%Y-%m-%d")}

set -e

PROJECT_PATH="${{1:-{project_path}}}"
ARTIFACTS_DIR="${{2:-{project_dir.resolve()}/artifacts}}"

# Validate project path
if [ ! -d "$PROJECT_PATH" ]; then
    echo "Error: Project path does not exist: $PROJECT_PATH"
    exit 1
fi

# Create artifacts directory
mkdir -p "$ARTIFACTS_DIR"

# Run build in Docker container
echo "Building {project_name}..."
docker run --rm \\
  -v "$PROJECT_PATH":/workspace \\
  -v "$ARTIFACTS_DIR":/artifacts \\
  -w /workspace/build \\
  {container_image} \\
  bash -c "cmake -G Ninja \\
           {formatted_flags} \\
           .. && \\
           ninja -j\\$(nproc)'''

        # Add IR artifact collection if enabled
        if enable_ir:
            script_content += ''' && \\
           echo 'Collecting LLVM IR artifacts...' && \\
           find . -name '*.bc' -o -name '*.ll' | xargs -I {{}} cp {{}} /artifacts/ 2>/dev/null || true"'''
        else:
            script_content += '''"'''

        # Add post-build steps
        script_content += f'''

# Copy compile_commands.json to project root
if [ -f "$PROJECT_PATH/build/compile_commands.json" ]; then
    cp "$PROJECT_PATH/build/compile_commands.json" "$PROJECT_PATH/"
    echo ""
    echo "Build complete."
    echo "  - compile_commands.json: $PROJECT_PATH/compile_commands.json"

    # Count IR artifacts if they were generated
    if [ -d "$ARTIFACTS_DIR" ]; then
        IR_COUNT=$(ls -1 "$ARTIFACTS_DIR"/*.bc "$ARTIFACTS_DIR"/*.ll 2>/dev/null | wc -l)
        if [ "$IR_COUNT" -gt 0 ]; then
            echo "  - LLVM IR artifacts: $ARTIFACTS_DIR ($IR_COUNT files)"
        fi
    fi
else
    echo "Warning: compile_commands.json not found in build directory"
    exit 1
fi
'''

        script_path = project_dir / "build.sh"
        script_path.write_text(script_content)
        script_path.chmod(0o755)  # Make executable

        return script_path

    def generate_readme(self) -> Path:
        """Generate README.md for the build-scripts directory."""
        readme_content = """# Build Scripts

This directory contains automatically generated build scripts for OSS projects analyzed with llm-summary.

## Structure

Each project has its own subdirectory:

```
build-scripts/
├── README.md           # This file
├── libpng/
│   ├── build.sh        # Reusable build script
│   ├── config.json     # Build configuration metadata
│   ├── build.log       # Last build output (if saved)
│   └── artifacts/      # LLVM IR files (.bc, .ll)
└── ...
```

## Usage

### Running a Build Script

```bash
# Use default project path (from when script was generated)
./libpng/build.sh

# Or specify custom paths
./libpng/build.sh /path/to/libpng /path/to/artifacts
```

### Script Parameters

1. **PROJECT_PATH** (optional): Path to the project source directory
   - Default: The path used when the script was generated

2. **ARTIFACTS_DIR** (optional): Where to store LLVM IR artifacts
   - Default: `build-scripts/<project>/artifacts/`

### What the Script Does

1. Validates project path exists
2. Creates artifacts directory
3. Runs CMake configuration in Docker with learned flags
4. Builds the project with Ninja
5. Collects LLVM IR artifacts (`.bc` and `.ll` files)
6. Copies `compile_commands.json` to project root

## Configuration Files

Each `config.json` contains:
- Project name and path
- Build system type (cmake, autotools, etc.)
- CMake flags learned by the build agent
- Generation timestamp

## Artifacts

LLVM IR artifacts are useful for:
- Static analysis with LLVM tools
- Dynamic analysis and instrumentation
- Understanding optimization behavior
- Cross-module analysis

## Regenerating Scripts

To regenerate a build script (e.g., after project updates):

```bash
llm-summary build-learn \\
  --project-path /path/to/project \\
  --backend vertex \\
  --verbose
```

This will update the existing script with newly learned configuration.
"""

        readme_path = self.scripts_base_dir / "README.md"
        self.scripts_base_dir.mkdir(parents=True, exist_ok=True)
        readme_path.write_text(readme_content)

        return readme_path
