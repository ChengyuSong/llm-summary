"""Parser for compile_commands.json to extract per-file compile flags."""

import json
import shlex
from pathlib import Path
from typing import Any


class CompileCommandsDB:
    """
    Parses compile_commands.json and provides per-file compile flags.

    compile_commands.json is generated by build systems like CMake with
    -DCMAKE_EXPORT_COMPILE_COMMANDS=ON, Bear, or other tools. It contains
    the exact compile flags used for each source file.
    """

    def __init__(self, compile_commands_path: str | Path | None = None):
        """
        Initialize the compile commands database.

        Args:
            compile_commands_path: Path to compile_commands.json file.
                                   If None, no per-file flags are available.
        """
        self._commands: dict[str, list[str]] = {}
        self._directory_map: dict[str, str] = {}

        if compile_commands_path:
            self._load(compile_commands_path)

    def _load(self, path: str | Path) -> None:
        """Load and parse the compile_commands.json file."""
        path = Path(path)
        if not path.exists():
            raise FileNotFoundError(f"compile_commands.json not found: {path}")

        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)

        for entry in data:
            self._parse_entry(entry)

    def _parse_entry(self, entry: dict[str, Any]) -> None:
        """Parse a single compile command entry."""
        file_path = entry.get("file", "")
        directory = entry.get("directory", "")

        # Normalize the file path
        if not Path(file_path).is_absolute():
            file_path = str(Path(directory) / file_path)
        file_path = str(Path(file_path).resolve())

        # Extract compile flags
        if "arguments" in entry:
            args = entry["arguments"]
        elif "command" in entry:
            args = shlex.split(entry["command"])
        else:
            return

        # Filter out the compiler and source file, keep relevant flags
        flags = self._extract_flags(args, file_path)

        self._commands[file_path] = flags
        self._directory_map[file_path] = directory

    def _extract_flags(self, args: list[str], source_file: str) -> list[str]:
        """
        Extract relevant compiler flags from command arguments.

        Keeps:
        - Include paths (-I, -isystem, -iquote)
        - Defines (-D)
        - Standard selection (-std=)
        - Other relevant flags

        Removes:
        - Compiler executable
        - Output file (-o and its argument)
        - Source file itself
        - Dependency generation flags (-M*, -MF, etc.)
        """
        flags = []
        skip_next = False

        for i, arg in enumerate(args):
            if skip_next:
                skip_next = False
                continue

            # Skip compiler executable (first argument usually)
            if i == 0 and (arg.endswith("cc") or arg.endswith("c++") or
                          arg.endswith("gcc") or arg.endswith("g++") or
                          arg.endswith("clang") or arg.endswith("clang++")):
                continue

            # Skip the source file itself
            if arg == source_file or arg.endswith(Path(source_file).name):
                continue

            # Skip output file arguments
            if arg == "-o":
                skip_next = True
                continue
            if arg.startswith("-o"):
                continue

            # Skip dependency generation flags
            if arg.startswith("-M") or arg.startswith("-MF"):
                if arg == "-MF" or arg == "-MT" or arg == "-MQ":
                    skip_next = True
                continue

            # Skip compile-only flag (we just want to parse, not compile)
            if arg == "-c":
                continue

            # Keep include paths
            if arg.startswith("-I") or arg.startswith("-isystem") or arg.startswith("-iquote"):
                flags.append(arg)
                continue

            # Keep defines
            if arg.startswith("-D"):
                flags.append(arg)
                continue

            # Keep standard selection
            if arg.startswith("-std="):
                flags.append(arg)
                continue

            # Keep warning flags (might affect parsing in edge cases)
            if arg.startswith("-W"):
                continue  # Actually skip these for clang parsing

            # Keep architecture flags
            if arg.startswith("-m") and not arg.startswith("-march"):
                continue  # Skip most -m flags

            # Keep target triple
            if arg == "-target" or arg.startswith("--target"):
                if arg == "-target":
                    if i + 1 < len(args):
                        flags.append(arg)
                        flags.append(args[i + 1])
                        skip_next = True
                else:
                    flags.append(arg)
                continue

            # Keep framework paths (macOS)
            if arg.startswith("-F"):
                flags.append(arg)
                continue

        return flags

    def get_compile_flags(self, file_path: str | Path) -> list[str]:
        """
        Get compile flags for a specific source file.

        Args:
            file_path: Path to the source file

        Returns:
            List of compiler flags for this file, or empty list if not found
        """
        file_path = str(Path(file_path).resolve())
        return self._commands.get(file_path, [])

    def get_directory(self, file_path: str | Path) -> str | None:
        """
        Get the working directory for compiling a specific file.

        Args:
            file_path: Path to the source file

        Returns:
            The directory from compile_commands.json, or None if not found
        """
        file_path = str(Path(file_path).resolve())
        return self._directory_map.get(file_path)

    def has_file(self, file_path: str | Path) -> bool:
        """Check if we have compile flags for a specific file."""
        file_path = str(Path(file_path).resolve())
        return file_path in self._commands

    def get_all_files(self) -> list[str]:
        """Get list of all files in the compile commands database."""
        return list(self._commands.keys())

    def __len__(self) -> int:
        """Return number of files in the database."""
        return len(self._commands)

    def __bool__(self) -> bool:
        """Return True if the database has any entries."""
        return len(self._commands) > 0
